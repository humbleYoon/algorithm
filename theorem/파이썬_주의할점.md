# 파이썬 주의할 점

- **BOJ는 numpy 등 외장모듈을 지원하지 않습니다.** (사실 모든 언어가 그렇습니다.)
- 풀이가 분명히 맞고 시간복잡도도 충분히 작은데 시간 초과가 난다면 언어를 Pypy로 설정하고 제출하면 됩니다. 파이썬은 원래 편리성과 속도를 맞바꾼 언어이기 때문에, 맞아야 될 풀이가 시간 초과더라도 이상할 게 전혀 없습니다.
- 사실 Pypy가 시간 초과더라도 이상할 건 전혀 없습니다. 상황에 맞는 언어를 사용하도록 합시다.
- **is 키워드는 두 대상의 값이 같은지가 아니라 완전히 같은 대상을 가리키는지를 비교합니다. BOJ에서 이걸 쓸 일은 거의 없습니다.** 같은 "hello"더라도 따로 정의하면 다른 대상이 됩니다. 이걸 쓰면 디버깅하기도 힘든 게, -5 이상 255 이하의 int는 미리 만들어 놓고 정의할 때마다 가져다 쓰기 때문에, 딱 그 범위까지는 is와 ==가 똑같은 동작을 합니다. 그래서 손으로 반례를 찾으려고 하면 찾아지지 않습니다.
- `list.pop(0), list.index, list.insert, list.count, x in list, list[:-1]` 등은 다 O(N)입니다. https://wiki.python.org/moin/TimeComplexity
- 위의 이유로, **list를 큐로 사용하면 절대, 절대, 절대, 절대, 절대 안 됩니다!! 큐는 반드시 collections.deque를 써야 합니다.**
- 아니요, `queue.Queue`도 안 됩니다. 이건 멀티스레딩을 위해 만들어진 큐이고 매우 느립니다.
- **파이썬의 재귀 깊이는 기본적으로 최대 1,000입니다.** `sys.setrecursionlimit`으로 이 깊이를 조절할 수 있습니다.
- Pypy의 재귀 깊이는 파이썬과 달리 딱 정해 놓은 제한이 없습니다. 하지만 10만 단위로 너무 깊이 들어가면 스택 오버플로가 나고, 그 제한은 파이썬보다 낮습니다. 또한 **Pypy는 재귀에 굉장히 약합니다.**
- 두 개의 int를 나누면 float이 됩니다. **int(a/b) 말고 a//b를 쓰는 것이 훨씬 안전합니다.** 맨 위의 "부동소수점 자료형은 나타내는 수의 범위가 넓지만 ..."을 읽어보세요.